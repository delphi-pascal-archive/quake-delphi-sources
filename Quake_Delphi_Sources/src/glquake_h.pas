// ------------------------------------------------------------------------------
//
// Copyright (C) 1996-1997 Id Software, Inc.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
//
// See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not,  write to the Free Software
// Foundation,  Inc., 59 Temple Place - Suite 330,  Boston,  MA  02111-1307, USA.
//
// ------------------------------------------------------------------------------
// Roman Vereshagin
// 
//

{$Z4}

unit glquake_h;

interface

uses
  Unit_SysTools,
  OpenGL12,
  bsp30,
  gl_planes,
  vid_h;

type
// Function prototypes for the Texture Object Extension routines
  BINDTEXFUNCPTR = procedure(num: TGLenum; u: TGLuint); stdcall;


// r_local.h -- private refresh defs
const
  ALIAS_BASE_SIZE_RATIO = (1.0 / 11.0);
          // normalizing factor so player model works out to about
          //  1 pixel per triangle
  MAX_LBM_HEIGHT = 480;

  TILE_SIZE = 128; // size of textures generated by R_GenTiledSurf

  SKYSHIFT = 7;
  SKYSIZE = 1 shl SKYSHIFT;
  SKYMASK = (SKYSIZE - 1);

  BACKFACE_EPSILON = 0.01;

(*
void R_TimeRefresh_f (void);
void R_ReadPointFile_f (void);
texture_t *R_TextureAnimation (texture_t *base);
*)

type
  PPsurfcache_t = ^Psurfcache_t;
  Psurfcache_t = ^surfcache_t;
  surfcache_t = record
    next: Psurfcache_t;
    owner: PPsurfcache_t; // NULL is an empty chunk of memory
    lightadj: array[0..MAXLIGHTMAPS - 1] of integer; // checked for strobe flush
    dlight: integer;
    size: integer; // including header
    width: unsigned;
    height: unsigned; // DEBUG only needed for debug
    mipscale: single;
    texture: Ptexture_t; // checked for animating textures
    data: array[0..3] of byte; // width*height elements
  end;


  drawsurf_t = record
    surfdat: PByte; //Ppixel_t;  // destination for generated surface
    rowbytes: integer; // destination logical width in bytes
    surf: Pmsurface_t; // description for surface to generate
    lightadj: array[0..MAXLIGHTMAPS - 1] of fixed8_t;
              // adjust for lightmap levels for dynamic lighting
    texture: Ptexture_t; // corrected for animating textures
    surfmip: integer; // mipmapped ratio of surface texels / world pixels
    surfwidth: integer; // in mipmapped texels
    surfheight: integer; // in mipmapped texels
  end;
  Pdrawsurf_t = ^drawsurf_t;


  ptype_t = (
    pt_static,
    pt_grav,
    pt_slowgrav,
    pt_fire,
    pt_explode,
    pt_explode2,
    pt_blob,
    pt_blob2
    );


// !!! if this is changed, it must be changed in d_ifacea.h too !!!
type
  Pparticle_t = ^particle_t;
  particle_t = record
// driver-usable fields
    org: TVector3f;
    color: single;
// drivers never touch the following fields
    next: Pparticle_t;
    vel: TVector3f;
    ramp: single;
    die: single;
    _type: ptype_t;
  end;

  particle_tArray = array[0..$FFFF] of particle_t;
  Pparticle_tArray = ^particle_tArray;


//====================================================

{
extern  entity_t  r_worldentity;
extern  qboolean  r_cache_thrash;    // compatability
extern  vec3_t    modelorg, r_entorigin;
extern  entity_t  *currententity;
extern  int      r_visframecount;  // ??? what difs?
extern  int      r_framecount;
extern  mplane_t  frustum[4];
extern  int    c_brush_polys, c_alias_polys;
}

{
//
// view origin
//
extern  vec3_t  vup;
extern  vec3_t  vpn;
extern  vec3_t  vright;
extern  vec3_t  r_origin;
}

{
//
// screen size info
//
extern  refdef_t  r_refdef;
extern  mleaf_t    *r_viewleaf, *r_oldviewleaf;
extern  texture_t  *r_notexture_mip;
extern  int    d_lightstylevalue[256];  // 8.8 fraction of base light value
}

{
extern  qboolean  envmap;
extern  int  currenttexture;
extern  int  cnttextures[2];
extern  int  particletexture;
extern  int  playertextures;

extern  int  skytexturenum;    // index in cl.loadmodel, not gl texture object

extern  cvar_t  r_norefresh;
extern  cvar_t  r_drawentities;
extern  cvar_t  r_drawworld;
extern  cvar_t  r_drawviewmodel;
extern  cvar_t  r_speeds;
extern  cvar_t  r_waterwarp;
extern  cvar_t  r_fullbright;
extern  cvar_t  r_lightmap;
extern  cvar_t  r_shadows;
extern  cvar_t  r_mirroralpha;
extern  cvar_t  r_wateralpha;
extern  cvar_t  r_dynamic;
extern  cvar_t  r_novis;

extern  cvar_t  gl_clear;
extern  cvar_t  gl_cull;
extern  cvar_t  gl_poly;
extern  cvar_t  gl_texsort;
extern  cvar_t  gl_smoothmodels;
extern  cvar_t  gl_affinemodels;
extern  cvar_t  gl_polyblend;
extern  cvar_t  gl_keeptjunctions;
extern  cvar_t  gl_reporttjunctions;
extern  cvar_t  gl_flashblend;
extern  cvar_t  gl_nocolors;
extern  cvar_t  gl_doubleeyes;

extern  int    gl_lightmap_format;
extern  int    gl_solid_format;
extern  int    gl_alpha_format;

extern  cvar_t  gl_max_size;
extern  cvar_t  gl_playermip;

extern  int      mirrortexturenum;  // quake texturenum, not gltexturenum
extern  qboolean  mirror;
extern  mplane_t  *mirror_plane;

extern  float  r_world_matrix[16];

extern  const char *gl_vendor;
extern  const char *gl_renderer;
extern  const char *gl_version;
extern  const char *gl_extensions;

void R_TranslatePlayerSkin (int playernum);
void GL_Bind (int texnum);
}

const
// Multitexture
  TEXTURE0_SGIS = $835E;
  TEXTURE1_SGIS = $835F;

{
#ifndef _WIN32
#define APIENTRY /* */
#endif
}

type
  lpMTexFUNC = procedure(num: TGLenum; f1: TGLfloat; f2: TGLfloat); stdcall;
  lpSelTexFUNC = procedure(num: TGLenum); stdcall;


var
  qglMTexCoord2fSGIS: lpMTexFUNC = nil;
  qglSelectTextureSGIS: lpSelTexFUNC = nil;

  mtexenabled: qboolean = false;

var
  particletexture: integer; // little dot for particles

{
extern lpMTexFUNC qglMTexCoord2fSGIS;
extern lpSelTexFUNC qglSelectTextureSGIS;
}
{
extern qboolean gl_mtexable;
}
{
void GL_DisableMultitexture(void);
void GL_EnableMultitexture(void);
}
implementation

end.

